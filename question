import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useGenerateFilter } from '../filterConfig/hooks/useGenerateFilter';
import { filterConfigsMap } from '../filterConfig/filterConfig';
import { useGlobalStore } from './useGlobalStore';
import useFetchUser from '../dataHooks/useFetchUser';
import { useFilterUpdater } from 'sdi-library';
import { 
  usePeriodFilter,
  useToDoCategoryFilter,
  useTodoTypeFilter,
  useToDoSubTypeFilter,
  useCampaignFilter,
  useClosedFilter,
  useBeforeDeadlineFilter,
  useCoverageFilter,
  useScopeFilter,
  useSeaStatutoryFilter,
  useRegionFilter,
  useBCFilter,
  useSubBCFilter,
  useSeaFilter,
  useRMFilter,
  useSegmentFilter,
  usePriorityFilter,
  useMainCategoryFilter,
  useCategoryFilter,
  useSubCategoryFilter,
} from '../hooks/filters'; // Adjust your imports as needed

//@ts-ignore
const FilterStoreContext = createContext();

// Serialize & Deserialize helpers
const serializeFilterValue = (value, isMulti) => {
  if (value == null) return null;
  return isMulti ? (Array.isArray(value) ? value.join(',') : String(value)) : String(value);
};

const deserializeFilterValue = (paramValue, isMulti, defaultValue) => {
  if (!paramValue) return isMulti ? [defaultValue] : defaultValue;
  if (isMulti) return paramValue.split(',').filter(Boolean);
  if (paramValue === 'true') return true;
  if (paramValue === 'false') return false;
  return paramValue;
};

export const FilterStoreProvider = ({ children }) => {
  const { refogId, setForcedLoadingArray } = useGlobalStore();
  const { user } = useFetchUser({ refogId });
  const [searchParams, setSearchParams] = useSearchParams();
  const [userFunction, setUserFunction] = useState('special');

  const isApplyingUrlParams = useRef(false);
  const pendingUrlValues = useRef({}); // queue pending URL values until options are ready

  // ---------------- Generate filters ----------------
  const period = useGenerateFilter({ filterFunction: usePeriodFilter, filterField: 'year', defaultValue: '2025' });
  const todocat = useGenerateFilter({ deps: [period.filterValue], depFields: ['year'], filterFunction: useToDoCategoryFilter, filterField: 'todoCategoryKey', isMulti: true });
  const todotype = useGenerateFilter({ deps: [period.filterValue, todocat.filterValue], depFields: ['year', 'todoCategoryKey'], filterFunction: useTodoTypeFilter, filterField: 'todoTypeKey', isMulti: true });
  const todosubtype = useGenerateFilter({ deps: [period.filterValue, todocat.filterValue, todotype.filterValue], depFields: ['year','todoCategoryKey','todoTypeKey'], filterFunction: useToDoSubTypeFilter, filterField: 'todoSubTypeKey', isMulti: true });
  const campaign = useGenerateFilter({ deps: [period.filterValue, todocat.filterValue, todotype.filterValue, todosubtype.filterValue], depFields: ['year','todoCategoryKey','todoTypeKey','todoSubTypeKey'], filterFunction: useCampaignFilter, filterField: 'fkCampaign', isMulti: true });
  const closed = useGenerateFilter({ filterFunction: useClosedFilter, filterField: 'closed', compareType: 'bool' });
  const beforeDeadline = useGenerateFilter({ filterFunction: useBeforeDeadlineFilter, filterField: 'beforeDeadline', compareType: 'bool' });

  const coverage = useGenerateFilter({ deps: [period.filterValue], depFields: ['year'], filterFunction: useCoverageFilter, filterField: 'level4Cd' });
  const scope = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue], depFields: ['year','level4Cd'], filterFunction: useScopeFilter, filterField: 'scopeKey' });
  const seaStatutory = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue], depFields: ['year','level4Cd','scopeKey'], filterFunction: useSeaStatutoryFilter, filterField: 'seaStatutoryKey' });
  const region = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue, seaStatutory.filterValue], depFields: ['year','level4Cd','scopeKey','seaStatutoryKey'], filterFunction: useRegionFilter, filterField: 'level5Cd' });
  const bc = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue, seaStatutory.filterValue, region.filterValue], depFields: ['year','level4Cd','scopeKey','seaStatutoryKey','level5Cd'], filterFunction: useBCFilter, filterField: 'level6Cd' });
  const subbc = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue, seaStatutory.filterValue, region.filterValue, bc.filterValue], depFields: ['year','level4Cd','scopeKey','seaStatutoryKey','level5Cd','level6Cd'], filterFunction: useSubBCFilter, filterField: 'level7Cd' });
  const sea = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue, seaStatutory.filterValue, region.filterValue, bc.filterValue, subbc.filterValue], depFields: ['year','level4Cd','scopeKey','seaStatutoryKey','level5Cd','level6Cd','level7Cd'], filterFunction: useSeaFilter, filterField: 'seaparentKey' });
  const rm = useGenerateFilter({ deps: [period.filterValue, coverage.filterValue, scope.filterValue, seaStatutory.filterValue, region.filterValue, bc.filterValue, subbc.filterValue, sea.filterValue], depFields: ['year','level4Cd','scopeKey','seaStatutoryKey','level5Cd','level6Cd','level7Cd','seaparentKey'], filterFunction: useRMFilter, filterField: 'level8Cd' });

  const segment = useGenerateFilter({ deps: [period.filterValue], depFields: ['year'], filterFunction: useSegmentFilter, filterField: 'segmentKey', isMulti: true });
  const priority = useGenerateFilter({ deps: [period.filterValue], depFields: ['year'], filterFunction: usePriorityFilter, filterField: 'priorityKey', isMulti: true });
  const maincategory = useGenerateFilter({ deps: [period.filterValue], depFields: ['year'], filterFunction: useMainCategoryFilter, filterField: 'mainCategoryKey', compareType: 'bit' });
  const category = useGenerateFilter({ deps: [period.filterValue, maincategory.filterValue], depFields: ['year','mainCategoryKey'], filterFunction: useCategoryFilter, filterField: 'categoryKey', hideWhenNoParentValue: true, compareType: 'bit' });
  const subcategory = useGenerateFilter({ deps: [period.filterValue, maincategory.filterValue, category.filterValue], depFields: ['year','mainCategoryKey','categoryKey'], filterFunction: useSubCategoryFilter, filterField: 'subCategoryKey', isMulti: true, hideWhenNoParentValue: true, compareType: 'bit' });

  const hooksMap = {
    period,todocat,todotype,todosubtype,campaign,closed,beforeDeadline,
    coverage,scope,seaStatutory,region,bc,subbc,sea,rm,segment,priority,
    maincategory,category,subcategory
  };

  // ---------------- Reset filters ----------------
  const resetFilters = useCallback(() => {
    Object.values(hooksMap).forEach(h => h.setFilterValue(h.isMulti ? [h.defaultValue] : h.defaultValue));
  }, []);

  // ---------------- Step 1: Capture URL params on mount ----------------
  useEffect(() => {
    Object.entries(hooksMap).forEach(([id, hook]) => {
      const paramValue = searchParams.get(id);
      if (!paramValue) return;
      pendingUrlValues.current[id] = deserializeFilterValue(paramValue, hook.isMulti, hook.defaultValue);
    });
  }, []);

  // ---------------- Step 2: Apply pending URL values when options are ready ----------------
  useEffect(() => {
    Object.entries(hooksMap).forEach(([id, hook]) => {
      if (!pendingUrlValues.current[id]) return;
      if (hook.filterLoading) return;

      const pendingValue = pendingUrlValues.current[id];
      const validValue = hook.isMulti
        ? pendingValue.filter(v => !hook.filterData?.options || hook.filterData.options.includes(v))
        : !hook.filterData?.options || hook.filterData.options.includes(pendingValue)
          ? pendingValue
          : hook.defaultValue;

      hook.setFilterValue(validValue);
      delete pendingUrlValues.current[id];
    });
  }, [
    ...Object.values(hooksMap).map(h => h.filterLoading),
    ...Object.values(hooksMap).map(h => h.filterData)
  ]);

  // ---------------- Step 3: Update URL when filters change ----------------
  useEffect(() => {
    if (isApplyingUrlParams.current) return;

    const newParams = new URLSearchParams();
    Object.entries(hooksMap).forEach(([id, hook]) => {
      const value = hook.filterValue !== undefined ? hook.filterValue : (hook.isMulti ? [hook.defaultValue] : hook.defaultValue);
      const serializedValue = serializeFilterValue(value, hook.isMulti);
      const defaultSerialized = serializeFilterValue(hook.isMulti ? [hook.defaultValue] : hook.defaultValue, hook.isMulti);

      if (serializedValue !== defaultSerialized) {
        newParams.set(id, serializedValue);
      }
    });

    if (newParams.toString() !== searchParams.toString()) {
      setSearchParams(newParams, { replace: true });
    }
  }, [...Object.values(hooksMap).map(h => h.filterValue)]);

  // ---------------- Dynamic config ----------------
  const [activeConfig,setActiveConfig] = useState(filterConfigsMap.special);
  useEffect(() => {
    setForcedLoadingArray([]);
    const userFunc = user?.currentUser?.securityRole;
    setUserFunction(userFunc);

    switch(userFunc) {
      case 'Special': setActiveConfig(filterConfigsMap.special); break;
      case 'AM': setActiveConfig(filterConfigsMap.am); break;
      case 'BCM': setActiveConfig(filterConfigsMap.bcm); break;
      case 'RM': setActiveConfig(filterConfigsMap.rm); break;
      default: setActiveConfig(filterConfigsMap.special); break;
    }
  }, [user]);

  // ---------------- Build filters array ----------------
  const [filters,setFilters] = useState([]);
  useEffect(() => {
    const newFilters = [];
    activeConfig.forEach(section => {
      newFilters.push({id:`title-${section.section}`,type:'title',label:section.section});
      section.filters.forEach(f => {
        const hook = hooksMap[f.id];
        if(!hook){
          newFilters.push({
            id: f.id,type:'select',label:f.label,state:undefined,
            handleChange:()=>{},handleManualUpdate:()=>{},
            options:[],optionsLabels:[],optionsSx:[],
            key:f.id,hide:f.hide,hideWhenNoParentValue:false,
            filterField:'',compareType:''
          });
          return;
        }
        newFilters.push({
          id:f.id,
          type: hook.isMulti?'multiselect':'select',
          label: f.label,
          state: hook.filterValue !== undefined ? hook.filterValue : (hook.isMulti?[hook.defaultValue]:hook.defaultValue),
          handleChange: hook.handleChange,
          handleManualUpdate: hook.handleManualUpdate,
          options: hook.filterData?.options || [],
          optionsLabels: hook.filterData?.optionsLabels || [],
          optionsSx: hook.filterData?.optionsSx || [],
          key: f.id,
          hide: f.hide,
          hideWhenNoParentValue: hook.hideWhenNoParentValue,
          filterField: hook.filterField,
          compareType: hook.compareType
        });
      });
    });
    setFilters(newFilters);
  }, [activeConfig, ...Object.values(hooksMap).map(h=>h.filterData), ...Object.values(hooksMap).map(h=>h.filterValue), userFunction]);

  // ---------------- Filter updater ----------------
  Object.entries(hooksMap).forEach(([id,hook])=>{
    useFilterUpdater(hook.filterData,id,setFilters,hook.filterValue,hook.setFilterValue,hook.defaultValue);
  });

  const isLoading = Object.values(hooksMap).some(h=>h.filterLoading);
  const isError = Object.values(hooksMap).some(h=>h.filterError);

  return (
    <FilterStoreContext.Provider value={{filters,setFilters,resetFilters,isLoading,isError}}>
      {children}
    </FilterStoreContext.Provider>
  );
};

export const useFilterStore = () => useContext(FilterStoreContext);