import React, { createContext, useContext, useEffect, useState } from 'react';
import { usePeriodFilter } from '../hooks/filters/viewFilters/usePeriodFilter';
import { useToDoCategoryFilter } from '../hooks/filters/viewFilters/useToDoCategoryFilter';
import { useCampaignFilter } from '../hooks/filters/viewFilters/useCampaignFilter';
import { useScopeFilter } from '../hooks/filters/entityFilters/useScopeFilter';
import { useCoverageFilter } from '../hooks/filters/entityFilters/useCoverageFilter';
import { useRegionFilter } from '../hooks/filters/entityFilters/useRegionFilter';
import { useBCFilter } from '../hooks/filters/entityFilters/useBCFilter';
import { useSubBCFilter } from '../hooks/filters/entityFilters/useSubBCFilter';
import { useRMFilter } from '../hooks/filters/entityFilters/useRMFilter';
import { useSegmentFilter } from '../hooks/filters/clientFilters/useSegmentFilter';
import { usePriorityFilter } from '../hooks/filters/clientFilters/usePriorityFilter';
import { useMainCategoryFilter } from '../hooks/filters/clientFilters/useMainCategoryFilter';
import { useCategoryFilter } from '../hooks/filters/clientFilters/useCategoryFilter';
import { useSubCategoryFilter } from '../hooks/filters/clientFilters/useSubCategoryFilter';
import { useTodoTypeFilter } from '../hooks/filters/viewFilters/useToDoTypeFilter';
import { useToDoSubTypeFilter } from '../hooks/filters/viewFilters/useToDoSubTypeFilter';
import { useGlobalStore } from './useGlobalStore';
import useFetchUser from '../dataHooks/useFetchUser';
import { useGenerateFilter } from '../filterConfig/hooks/useGenerateFilter';
import { filterConfigsMap } from '../filterConfig/filterConfig';
import { useFilterUpdater } from 'sdi-library';
import { useClosedFilter } from '../hooks/filters/viewFilters/useClosedFilter';
import { useBeforeDeadlineFilter } from '../hooks/filters/viewFilters/useBeforeDeadlineFilter';
import { useSeaFilter } from '../hooks/filters/entityFilters/useSeaFilter';
import { useSeaStatutoryFilter } from '../hooks/filters/entityFilters/useSeaStatutoryFilter';

//@ts-ignore
const FilterStoreContext = createContext();

export const FilterStoreProvider = ({ children }) => {
  const { refogId, setForcedLoadingArray } = useGlobalStore();
  const { user } = useFetchUser({ refogId });
  const [userFunction, setUserFunction] = useState('special');

  // ---------------- Static hooks for all filters ----------------
  const period = useGenerateFilter({
    filterFunction: usePeriodFilter,
    filterField: 'year',
    defaultValue: '2025',
  });
  const todocat = useGenerateFilter({
    deps: [period.filterValue],
    depFields: ['year'],
    filterFunction: useToDoCategoryFilter,
    filterField: 'todoCategoryKey',
    isMulti: true,
  });
  const todotype = useGenerateFilter({
    deps: [period.filterValue, todocat.filterValue],
    depFields: ['year', 'todoCategoryKey'],
    filterFunction: useTodoTypeFilter,
    filterField: 'todoTypeKey',
    isMulti: true,
  });
  const todosubtype = useGenerateFilter({
    deps: [period.filterValue, todocat.filterValue, todotype.filterValue],
    depFields: ['year', 'todoCategoryKey', 'todoTypeKey'],
    filterFunction: useToDoSubTypeFilter,
    filterField: 'todoSubTypeKey',
    isMulti: true,
  });
  const campaign = useGenerateFilter({
    deps: [
      period.filterValue,
      todocat.filterValue,
      todotype.filterValue,
      todosubtype.filterValue,
    ],
    depFields: ['year', 'todoCategoryKey', 'todoTypeKey', 'todoSubTypeKey'],
    filterFunction: useCampaignFilter,
    filterField: 'fkCampaign',
    isMulti: true,
  });
  const closed = useGenerateFilter({
    filterFunction: useClosedFilter,
    filterField: 'closed',
    compareType: 'bool',
  });
  const beforeDeadline = useGenerateFilter({
    filterFunction: useBeforeDeadlineFilter,
    filterField: 'beforeDeadline',
    compareType: 'bool',
  });

  const coverage = useGenerateFilter({
    deps: [period.filterValue],
    depFields: ['year'],
    filterFunction: useCoverageFilter,
    filterField: 'level4Cd',
  });
  const scope = useGenerateFilter({
    deps: [period.filterValue, coverage.filterValue],
    depFields: ['year', 'level4Cd'],
    filterFunction: useScopeFilter,
    filterField: 'scopeKey',
  });
  const seaStatutory = useGenerateFilter({
    deps: [period.filterValue, coverage.filterValue, scope.filterValue],
    depFields: ['year', 'level4Cd', 'scopeKey'],
    filterFunction: useSeaStatutoryFilter,
    filterField: 'seaStatutoryKey',
  });
  const region = useGenerateFilter({
    deps: [
      period.filterValue,
      coverage.filterValue,
      scope.filterValue,
      seaStatutory.filterValue,
    ],
    depFields: ['year', 'level4Cd', 'scopeKey', 'seaStatutoryKey'],
    filterFunction: useRegionFilter,
    filterField: 'level5Cd',
  });
  const bc = useGenerateFilter({
    deps: [
      period.filterValue,
      coverage.filterValue,
      scope.filterValue,
      seaStatutory.filterValue,
      region.filterValue,
    ],
    depFields: ['year', 'level4Cd', 'scopeKey', 'seaStatutoryKey', 'level5Cd'],
    filterFunction: useBCFilter,
    filterField: 'level6Cd',
  });
  const subbc = useGenerateFilter({
    deps: [
      period.filterValue,
      coverage.filterValue,
      scope.filterValue,
      seaStatutory.filterValue,
      region.filterValue,
      bc.filterValue,
    ],
    depFields: [
      'year',
      'level4Cd',
      'scopeKey',
      'seaStatutoryKey',
      'level5Cd',
      'level6Cd',
    ],
    filterFunction: useSubBCFilter,
    filterField: 'level7Cd',
  });
  const sea = useGenerateFilter({
    deps: [
      period.filterValue,
      coverage.filterValue,
      scope.filterValue,
      seaStatutory.filterValue,
      region.filterValue,
      bc.filterValue,
      subbc.filterValue,
    ],
    depFields: [
      'year',
      'level4Cd',
      'scopeKey',
      'seaStatutoryKey',
      'level5Cd',
      'level6Cd',
      'level7Cd',
    ],
    filterFunction: useSeaFilter,
    filterField: 'seaparentKey',
  });
  const rm = useGenerateFilter({
    deps: [
      period.filterValue,
      coverage.filterValue,
      scope.filterValue,
      seaStatutory.filterValue,
      region.filterValue,
      bc.filterValue,
      subbc.filterValue,
      sea.filterValue,
    ],
    depFields: [
      'year',
      'level4Cd',
      'scopeKey',
      'seaStatutoryKey',
      'level5Cd',
      'level6Cd',
      'level7Cd',
      'seaparentKey',
    ],
    filterFunction: useRMFilter,
    filterField: 'level8Cd',
  });

  const segment = useGenerateFilter({
    deps: [period.filterValue],
    depFields: ['year'],
    filterFunction: useSegmentFilter,
    filterField: 'segmentKey',
    isMulti: true,
  });
  const priority = useGenerateFilter({
    deps: [period.filterValue],
    depFields: ['year'],
    filterFunction: usePriorityFilter,
    filterField: 'priorityKey',
    isMulti: true,
  });
  const maincategory = useGenerateFilter({
    deps: [period.filterValue],
    depFields: ['year'],
    filterFunction: useMainCategoryFilter,
    filterField: 'mainCategoryKey',
    compareType: 'bit',
  });
  const category = useGenerateFilter({
    deps: [period.filterValue, maincategory.filterValue],
    depFields: ['year', 'mainCategoryKey'],
    filterFunction: useCategoryFilter,
    filterField: 'categoryKey',
    hideWhenNoParentValue: true,
    compareType: 'bit',
  });
  const subcategory = useGenerateFilter({
    deps: [period.filterValue, maincategory.filterValue, category.filterValue],
    depFields: ['year', 'mainCategoryKey', 'categoryKey'],
    filterFunction: useSubCategoryFilter,
    filterField: 'subCategoryKey',
    isMulti: true,
    hideWhenNoParentValue: true,
    compareType: 'bit',
  });

  const hooksMap = {
    period,
    todocat,
    todotype,
    todosubtype,
    campaign,
    closed,
    beforeDeadline,
    coverage,
    scope,
    seaStatutory,
    region,
    bc,
    subbc,
    sea,
    rm,
    segment,
    priority,
    maincategory,
    category,
    subcategory,
  };

  // ---------------- Dynamic config based on user.function ----------------
  const [activeConfig, setActiveConfig] = useState(filterConfigsMap.special);
  useEffect(() => {
    resetFilters(); // Reset filters
    setForcedLoadingArray([]); // Reset loading states

    const userFunc = user?.currentUser?.securityRole;
    setUserFunction(userFunc);

    console.log('userFunc', userFunc);

    switch (userFunc) {
      case 'Special':
        setActiveConfig(filterConfigsMap.special);
        break;
      case 'AM':
        setActiveConfig(filterConfigsMap.am);
        break;
      case 'BCM':
        setActiveConfig(filterConfigsMap.bcm);
        break;
      case 'RM':
        setActiveConfig(filterConfigsMap.rm);
        break;
      default:
        setActiveConfig(filterConfigsMap.special); // Default case if userFunc doesn't match any case
        break;
    }
  }, [user, setUserFunction, setActiveConfig]);

  // ---------------- Build filters array with real options & defaultValue state ----------------
  const [filters, setFilters] = useState([]);

  useEffect(() => {
    // Map existing filters by id for quick reuse
    const existingMap = Object.fromEntries(filters.map((f) => [f.id, f]));

    // Build new filters array following config order
    const newFilters = [];

    activeConfig.forEach((section) => {
      // title object (use stable id for title as well)
      const titleObj = {
        id: `title-${section.section}`,
        type: 'title',
        label: section.section,
      };
      newFilters.push(titleObj);

      section.filters.forEach((f) => {
        const hook = hooksMap[f.id];
        // If for some reason hook is missing, create a placeholder (keeps order)
        if (!hook) {
          newFilters.push({
            id: f.id,
            type: 'select',
            label: f.label,
            state: undefined,
            handleChange: () => {},
            handleManualUpdate: () => {},
            options: [],
            optionsLabels: [],
            optionsSx: [],
            // parentDeps: f.parentDeps || [],
            key: f.id,
            hide: f.hide,
            hideWhenNoParentValue: false,
            filterField: '',
            compareType: '',
          });
          return;
        }

        const existing = existingMap[f.id];

        if (existing) {
          // Re-use the exact existing object to preserve identity in the array.
          // Update its fields in-place so UI sees latest values while DOM node remains reused.
          existing.type = hook.isMulti ? 'multiselect' : 'select';
          existing.label = f.label;
          existing.state =
            hook.filterValue !== undefined
              ? hook.filterValue
              : hook.isMulti
              ? [hook.defaultValue]
              : hook.defaultValue;
          existing.handleChange = hook.handleChange;
          existing.handleManualUpdate = hook.handleManualUpdate;
          existing.options = hook.filterData?.options || [];
          existing.optionsLabels = hook.filterData?.optionsLabels || [];
          existing.optionsSx = hook.filterData?.optionsSx || [];
          // existing.parentDeps = f.parentDeps || [];
          existing.key = f.id; // stable key
          existing.hide = f.hide;
          existing.hideWhenNoParentValue = hook.hideWhenNoParentValue;
          existing.filterField = hook.filterField;
          existing.compareType = hook.compareType;
          newFilters.push(existing);
        } else {
          // New filter â€” create object in correct position
          const newFilter = {
            id: f.id,
            type: hook.isMulti ? 'multiselect' : 'select',
            label: f.label,
            state:
              hook.filterValue !== undefined
                ? hook.filterValue
                : hook.isMulti
                ? [hook.defaultValue]
                : hook.defaultValue,
            handleChange: hook.handleChange,
            handleManualUpdate: hook.handleManualUpdate,
            options: hook.filterData?.options || [],
            optionsLabels: hook.filterData?.optionsLabels || [],
            optionsSx: hook.filterData?.optionsSx || [],
            // parentDeps: f.parentDeps || [],
            key: f.id,
            hide: f.hide,
            hideWhenNoParentValue: hook.hideWhenNoParentValue,
            filterField: hook.filterField,
            compareType: hook.compareType,
          };
          newFilters.push(newFilter);
        }
      });
    });

    // Replace filters with new ordered array (we reused objects whenever possible)
    setFilters(newFilters);
  }, [
    activeConfig,
    // depend on hook data and values so effect runs when they change
    ...Object.values(hooksMap).map((h) => h.filterData),
    ...Object.values(hooksMap).map((h) => h.filterValue),
    // and also react to userFunction changes if you set it elsewhere
    userFunction,
  ]);

  // ---------------- Filter updater ----------------
  Object.entries(hooksMap).forEach(([id, hook]) => {
    useFilterUpdater(
      hook.filterData,
      id,
      setFilters,
      hook.filterValue,
      hook.setFilterValue,
      hook.defaultValue
    );
  });

  // ---------------- Reset filters ----------------
  const resetFilters = () => {
    Object.values(hooksMap).forEach((h) =>
      h.setFilterValue(h.isMulti ? [h.defaultValue] : h.defaultValue)
    );
  };

  // ---------------- Loading / Error ----------------
  const isLoading = Object.values(hooksMap).some((h) => h.filterLoading);
  const isError = Object.values(hooksMap).some((h) => h.filterError);

  return (
    <FilterStoreContext.Provider
      value={{ filters, setFilters, resetFilters, isLoading, isError }}>
      {children}
    </FilterStoreContext.Provider>
  );
};

export const useFilterStore = () => useContext(FilterStoreContext);



// Define multiple configs based on user.function
export const filterConfigsMap = {
    special: [
        {
            section: 'VIEW FILTERS',
            filters: [
                { id: 'period', label: 'Year Deadline' },
                { id: 'todocat', label: 'To Do Category' },
                { id: 'todotype', label: 'To Do Type' },
                { id: 'todosubtype', label: 'To Do SubType' },
                { id: 'campaign', label: 'Campaign' },
                { id: 'closed', label: 'Open/Closed' },
                { id: 'beforeDeadline', label: 'Before/After deadline' },
            ],
        },
        {
            section: 'ENTITY FILTERS',
            filters: [
                { id: 'coverage', label: 'Coverage' },
                { id: 'scope', label: 'Scope' },
                { id: 'seaStatutory', label: 'SEA/Statutory' },
                { id: 'region', label: 'Region' },
                { id: 'bc', label: 'BC/Zone' },
                { id: 'subbc', label: 'Sub-BC/Sub-Zone' },
                { id: 'sea', label: 'SEA' },
                { id: 'rm', label: 'RM/Advisor' },
            ],
        },
        {
            section: 'CLIENT FILTERS',
            filters: [
                { id: 'segment', label: 'Segment' },
                { id: 'priority', label: 'Priority' },
                { id: 'maincategory', label: 'Main Category' },
                { id: 'category', label: 'Category' },
                { id: 'subcategory', label: 'SubCategory' },
            ],
        },
    ],

    am: [
        {
            section: 'VIEW FILTERS',
            filters: [
                { id: 'period', label: 'Year Deadline' },
                { id: 'todocat', label: 'To Do Category' },
                { id: 'todotype', label: 'To Do Type' },
                { id: 'todosubtype', label: 'To Do SubType' },
                { id: 'campaign', label: 'Campaign' },
                { id: 'closed', label: 'Open/Closed' },
                { id: 'beforeDeadline', label: 'Before/After deadline' },
            ],
        },
        {
            section: 'ENTITY FILTERS',
            filters: [
                { id: 'coverage', label: 'Coverage', hide: true },
                { id: 'scope', label: 'Scope' },
                { id: 'seaStatutory', label: 'SEA/Statutory' },
                { id: 'region', label: 'Region' },
                { id: 'bc', label: 'BC/Zone' },
                { id: 'subbc', label: 'Sub-BC/Sub-Zone' },
                { id: 'sea', label: 'SEA' },
                { id: 'rm', label: 'RM/Advisor' },
            ],
        },
        {
            section: 'CLIENT FILTERS',
            filters: [
                { id: 'segment', label: 'Segment' },
                { id: 'priority', label: 'Priority' },
                { id: 'maincategory', label: 'Main Category' },
                { id: 'category', label: 'Category' },
                { id: 'subcategory', label: 'SubCategory' },
            ],
        },
    ],

    bcm: [
        {
            section: 'VIEW FILTERS',
            filters: [
                { id: 'period', label: 'Year Deadline' },
                { id: 'todocat', label: 'To Do Category' },
                { id: 'todotype', label: 'To Do Type' },
                { id: 'todosubtype', label: 'To Do SubType' },
                { id: 'campaign', label: 'Campaign' },
                { id: 'closed', label: 'Open/Closed' },
                { id: 'beforeDeadline', label: 'Before/After deadline' },
            ],
        },
        {
            section: 'ENTITY FILTERS',
            filters: [
                { id: 'coverage', label: 'Coverage', hide: true },
                { id: 'scope', label: 'Scope' },
                { id: 'seaStatutory', label: 'SEA/Statutory' },
                { id: 'region', label: 'Region', hide: true },
                { id: 'bc', label: 'BC/Zone' },
                { id: 'subbc', label: 'Sub-BC/Sub-Zone' },
                { id: 'sea', label: 'SEA' },
                { id: 'rm', label: 'RM/Advisor' },
            ],
        },
        {
            section: 'CLIENT FILTERS',
            filters: [
                { id: 'segment', label: 'Segment' },
                { id: 'priority', label: 'Priority' },
                { id: 'maincategory', label: 'Main Category' },
                { id: 'category', label: 'Category' },
                { id: 'subcategory', label: 'SubCategory' },
            ],
        },
    ],

    rm: [
        {
            section: 'VIEW FILTERS',
            filters: [
                { id: 'period', label: 'Year Deadline' },
                { id: 'todocat', label: 'To Do Category' },
                { id: 'todotype', label: 'To Do Type' },
                { id: 'todosubtype', label: 'To Do SubType' },
                { id: 'campaign', label: 'Campaign' },
                { id: 'closed', label: 'Open/Closed' },
                { id: 'beforeDeadline', label: 'Before/After deadline' },
            ],
        },
        {
            section: 'ENTITY FILTERS',
            filters: [
                { id: 'coverage', label: 'Coverage', hide: true },
                { id: 'scope', label: 'Scope', hide: true },
                { id: 'seaStatutory', label: 'SEA/Statutory', hide: true },
                { id: 'region', label: 'Region', hide: true },
                { id: 'bc', label: 'BC/Zone', hide: true },
                { id: 'subbc', label: 'Sub-BC/Sub-Zone' },
                { id: 'sea', label: 'SEA', hide: true },
                { id: 'rm', label: 'RM/Advisor' },
            ],
        },
        {
            section: 'CLIENT FILTERS',
            filters: [
                { id: 'segment', label: 'Segment' },
                { id: 'priority', label: 'Priority' },
                { id: 'maincategory', label: 'Main Category' },
                { id: 'category', label: 'Category' },
                { id: 'subcategory', label: 'SubCategory' },
            ],
        },
    ],
};



import React, { useEffect, useState } from 'react';
import {
  BrowserRouter,
  Navigate,
  Route,
  Routes,
  useLocation,
  useNavigate,
} from 'react-router-dom';
import Layout from './Layout';
import useFetchUser from './dataHooks/useFetchUser';
import useRoutes from './hooks/useRoutes';
import { LoadingScreen, ScrollToTopOnRouteSwitch } from 'sdi-library';
import { FilterStoreProvider } from './contexts/useFilterStore';
import { useGlobalStore } from './contexts/useGlobalStore';
import { SWRConfig } from 'swr';

function localStorageProvider() {
  const map = new Map(JSON.parse(localStorage.getItem('swr-cache') || '[]'));
  window.addEventListener('beforeunload', () => {
    const appCache = JSON.stringify(Array.from(map.entries()));
    localStorage.setItem('swr-cache', appCache);
  });
  return map;
}

const AppContent = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { refogId } = useGlobalStore();

  const { user, isLoadingUser, errorUser } = useFetchUser({ refogId });
  const {
    filteredRoutes,
    homeRoute,
    notFoundRoute,
    noAccessRoute,
    messageRoute,
  } = useRoutes();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (isLoadingUser) {
      setIsLoading(true);
    } else if (errorUser) {
      setError(errorUser);
      setIsLoading(false);
    } else if (user === undefined || user === null) {
      setError('No data found for user');
      setIsLoading(false);
      // } else if (user.isAdmin && location.pathname === messageRoute.path) {
    } else if (location.pathname === messageRoute.path) {
      if (!user.isAdmin) setError('ERROR');
      setIsLoading(false);
    } else {
      setIsLoading(false);
    }
  }, [isLoadingUser, errorUser, location, user]);

  useEffect(() => {
    if (error) {
      console.error('Error with user: ', error);
      navigate('/no-access');
    }
  }, [error, navigate]);

  if (isLoading) return <LoadingScreen />;

  if (error) {
    return (
      <Routes>
        <Route
          path={noAccessRoute.path}
          element={<noAccessRoute.component />}
        />
      </Routes>
    );
  }

  if (location.pathname === messageRoute.path) {
    <Routes>
      <Route path={messageRoute.path} element={<messageRoute.component />} />
    </Routes>;
  }

  if (user?.currentUser?.securityRole === 'NoneForNow') {
    return (
      <FilterStoreProvider>
        <Routes>
          <Route
            path={noAccessRoute.path}
            element={<noAccessRoute.component />}
          />
          <Route path={homeRoute.path} element={<Layout />}>
            <Route element={<homeRoute.component />}>
              <Route index element={<></>} />
            </Route>

            <Route
              path={notFoundRoute.path}
              element={<notFoundRoute.component />}
            />
            <Route
              path={messageRoute.path}
              element={<messageRoute.component />}
            />
            <Route
              path="*"
              element={<Navigate to={homeRoute.path} replace />}
            />
          </Route>
        </Routes>
      </FilterStoreProvider>
    );
  }

  return (
    <FilterStoreProvider>
      <Routes>
        <Route
          path={noAccessRoute.path}
          element={<noAccessRoute.component />}
        />
        <Route path={homeRoute.path} element={<Layout />}>
          <Route element={<homeRoute.component />}>
            <Route index element={<></>} />
          </Route>
          {filteredRoutes.map((d) => (
            <Route key={d.id} path={d.path} element={<d.component />}></Route>
          ))}
          <Route
            path={notFoundRoute.path}
            element={<notFoundRoute.component />}
          />
          <Route
            path={messageRoute.path}
            element={<messageRoute.component />}
          />
          <Route path="*" element={<Navigate to={homeRoute.path} replace />} />
        </Route>
      </Routes>
    </FilterStoreProvider>
  );
};

function App() {
  return (
    <SWRConfig value={{ provider: localStorageProvider }}>
      <BrowserRouter>
        <ScrollToTopOnRouteSwitch />
        <AppContent />
      </BrowserRouter>
    </SWRConfig>
  );
}

export default App;
