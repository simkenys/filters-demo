import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useGenerateFilter } from '../filterConfig/hooks/useGenerateFilter';
import { filterConfigsMap } from '../filterConfig/filterConfig';
import { useGlobalStore } from './useGlobalStore';
import useFetchUser from '../dataHooks/useFetchUser';
import { useFilterUpdater } from 'sdi-library';

//@ts-ignore
const FilterStoreContext = createContext();

// Serialize & Deserialize helpers
const serializeFilterValue = (value, isMulti) => {
  if (value == null) return null;
  return isMulti ? (Array.isArray(value) ? value.join(',') : String(value)) : String(value);
};

const deserializeFilterValue = (paramValue, isMulti, defaultValue) => {
  if (!paramValue) return isMulti ? [defaultValue] : defaultValue;
  if (isMulti) return paramValue.split(',').filter(Boolean);
  if (paramValue === 'true') return true;
  if (paramValue === 'false') return false;
  return paramValue;
};

export const FilterStoreProvider = ({ children }) => {
  const { refogId, setForcedLoadingArray } = useGlobalStore();
  const { user } = useFetchUser({ refogId });
  const [searchParams, setSearchParams] = useSearchParams();
  const [userFunction, setUserFunction] = useState('special');

  const isApplyingUrlParams = useRef(false);

  // ---------------- Generate filters ----------------
  // Example filter, repeat for all filters
  const period = useGenerateFilter({
    filterFunction: usePeriodFilter,
    filterField: 'year',
    defaultValue: '2025',
  });

  // Build your hooksMap as before
  const hooksMap = { period /* ... all other filters ... */ };

  // ---------------- Pending URL values ----------------
  const pendingUrlValues = useRef({});

  // ---------------- Step 1: Capture URL params on mount ----------------
  useEffect(() => {
    Object.entries(hooksMap).forEach(([id, hook]) => {
      const paramValue = searchParams.get(id);
      if (!paramValue) return;

      pendingUrlValues.current[id] = deserializeFilterValue(
        paramValue,
        hook.isMulti,
        hook.defaultValue
      );
    });
  }, []);

  // ---------------- Step 2: Apply pending URL values when options are ready ----------------
  useEffect(() => {
    Object.entries(hooksMap).forEach(([id, hook]) => {
      if (!pendingUrlValues.current[id]) return;
      if (hook.filterLoading) return; // wait until options are loaded

      const pendingValue = pendingUrlValues.current[id];

      // Validate against available options if applicable
      const validValue = hook.isMulti
        ? pendingValue.filter((v) => !hook.filterData?.options || hook.filterData.options.includes(v))
        : !hook.filterData?.options || hook.filterData.options.includes(pendingValue)
        ? pendingValue
        : hook.defaultValue;

      hook.setFilterValue(validValue);
      delete pendingUrlValues.current[id];
    });
  }, [
    ...Object.values(hooksMap).map((h) => h.filterLoading),
    ...Object.values(hooksMap).map((h) => h.filterData),
  ]);

  // ---------------- Step 3: Update URL whenever filters change ----------------
  useEffect(() => {
    if (isApplyingUrlParams.current) return;

    const params = new URLSearchParams();
    Object.entries(hooksMap).forEach(([id, hook]) => {
      const value = hook.filterValue !== undefined ? hook.filterValue : hook.defaultValue;
      const serialized = serializeFilterValue(value, hook.isMulti);
      const defaultSerialized = serializeFilterValue(hook.isMulti ? [hook.defaultValue] : hook.defaultValue, hook.isMulti);

      if (serialized !== defaultSerialized) {
        params.set(id, serialized);
      }
    });

    if (params.toString() !== searchParams.toString()) {
      setSearchParams(params, { replace: true });
    }
  }, [...Object.values(hooksMap).map((h) => h.filterValue)]);

  // ---------------- Step 4: Dynamic config based on user role ----------------
  const [activeConfig, setActiveConfig] = useState(filterConfigsMap.special);
  useEffect(() => {
    setForcedLoadingArray([]);

    const userFunc = user?.currentUser?.securityRole;
    setUserFunction(userFunc);

    switch (userFunc) {
      case 'Special':
        setActiveConfig(filterConfigsMap.special);
        break;
      case 'AM':
        setActiveConfig(filterConfigsMap.am);
        break;
      case 'BCM':
        setActiveConfig(filterConfigsMap.bcm);
        break;
      case 'RM':
        setActiveConfig(filterConfigsMap.rm);
        break;
      default:
        setActiveConfig(filterConfigsMap.special);
        break;
    }
  }, [user]);

  // ---------------- Step 5: Build filters array ----------------
  const [filters, setFilters] = useState([]);
  useEffect(() => {
    const newFilters = [];

    activeConfig.forEach((section) => {
      newFilters.push({ id: `title-${section.section}`, type: 'title', label: section.section });
      section.filters.forEach((f) => {
        const hook = hooksMap[f.id];
        if (!hook) return;
        newFilters.push({
          id: f.id,
          type: hook.isMulti ? 'multiselect' : 'select',
          label: f.label,
          state: hook.filterValue !== undefined ? hook.filterValue : (hook.isMulti ? [hook.defaultValue] : hook.defaultValue),
          handleChange: hook.handleChange,
          handleManualUpdate: hook.handleManualUpdate,
          options: hook.filterData?.options || [],
          optionsLabels: hook.filterData?.optionsLabels || [],
          optionsSx: hook.filterData?.optionsSx || [],
          key: f.id,
          hide: f.hide,
          hideWhenNoParentValue: hook.hideWhenNoParentValue,
          filterField: hook.filterField,
          compareType: hook.compareType,
        });
      });
    });

    setFilters(newFilters);
  }, [
    activeConfig,
    ...Object.values(hooksMap).map((h) => h.filterData),
    ...Object.values(hooksMap).map((h) => h.filterValue),
    userFunction,
  ]);

  // ---------------- Step 6: Filter updater ----------------
  Object.entries(hooksMap).forEach(([id, hook]) => {
    useFilterUpdater(
      hook.filterData,
      id,
      setFilters,
      hook.filterValue,
      hook.setFilterValue,
      hook.defaultValue
    );
  });

  const isLoading = Object.values(hooksMap).some((h) => h.filterLoading);
  const isError = Object.values(hooksMap).some((h) => h.filterError);

  const resetFilters = useCallback(() => {
    Object.values(hooksMap).forEach((h) =>
      h.setFilterValue(h.isMulti ? [h.defaultValue] : h.defaultValue)
    );
  }, []);

  return (
    <FilterStoreContext.Provider
      value={{ filters, setFilters, resetFilters, isLoading, isError }}
    >
      {children}
    </FilterStoreContext.Provider>
  );
};

export const useFilterStore = () => useContext(FilterStoreContext);