import { useEffect, useRef } from "react";

const useFilterUpdater = (
  data,
  id,
  setFilters,
  state,
  setState,
  defaultValue = null,
  urlOverride = null
) => {
  // Track previous options to detect when they actually change
  const prevOptionsRef = useRef(null);
  const prevStateRef = useRef(state);

  useEffect(() => {
    if (!data) return;

    const newOptions = data.options || [];
    const newOptionsLabels = data.optionsLabels || [];
    const newOptionsSx = data.optionsSx || [];

    // Check if options actually changed (not just re-rendered)
    const optionsChanged =
      JSON.stringify(prevOptionsRef.current) !== JSON.stringify(newOptions);
    prevOptionsRef.current = newOptions;

    let updatedState;
    const updatedFilters = (prevFilters) =>
      prevFilters.map((filter) => {
        if (filter.id === id) {
          if (Array.isArray(state)) {
            // multi select

            // PRIORITY 1: Try to preserve URL override if it's valid
            if (urlOverride && Array.isArray(urlOverride)) {
              const validUrlValues = urlOverride.filter((d) =>
                newOptions.includes(d)
              );
              if (validUrlValues.length > 0) {
                updatedState = validUrlValues;
              } else {
                // URL values not in options yet, keep them temporarily
                updatedState = urlOverride;
              }
            } else {
              // PRIORITY 2: Try to preserve ALL current state values
              const matchingStates = state.filter((d) =>
                newOptions.includes(d)
              );

              // KEY FIX: Check if ALL current values are still valid
              // If all current values exist in new options, keep them regardless
              const allCurrentValuesStillValid = state.every((d) =>
                newOptions.includes(d)
              );

              if (allCurrentValuesStillValid && state.length > 0) {
                // All values are still valid, keep the entire current state
                updatedState = state;
              } else if (matchingStates.length > 0) {
                // Some values are valid, keep only those
                updatedState = matchingStates;
              } else if (optionsChanged) {
                // No matches and options changed, use default
                updatedState = defaultValue
                  ? [defaultValue]
                  : newOptions[0] ?? [""];
              } else {
                // No matches but options didn't change, keep current state
                updatedState = state;
              }
            }
          } else {
            // single select

            // PRIORITY 1: Try to preserve URL override if it's valid
            if (urlOverride !== null) {
              const isUrlValid = newOptions.includes(urlOverride);
              if (isUrlValid) {
                updatedState = urlOverride;
              } else {
                // URL value not in options yet, keep it temporarily
                updatedState = urlOverride;
              }
            } else {
              // PRIORITY 2: Try to preserve current state
              const isStateValid = newOptions.includes(state);

              if (isStateValid) {
                // Current state is valid, keep it
                updatedState = state;
              } else if (optionsChanged) {
                // State invalid and options changed, use default
                updatedState = defaultValue ?? newOptions[0] ?? "";
              } else {
                // State invalid but options didn't change, keep current state
                updatedState = state;
              }
            }
          }

          return {
            ...filter,
            state: updatedState,
            options: newOptions,
            optionsLabels: newOptionsLabels,
            optionsSx: newOptionsSx,
          };
        }
        return filter;
      });

    setFilters((prevFilters) => {
      const newFilters = updatedFilters(prevFilters);

      // Only update state if it actually changed
      if (JSON.stringify(state) !== JSON.stringify(updatedState)) {
        console.error(
          "(SIMKE) TODO: FIX - When parent value changes to an previous unfetched combo, some/all children get reset!"
        );
        console.log(`[${id}] State update:`, {
          from: state,
          to: updatedState,
          reason: optionsChanged ? "options changed" : "validation",
        });
        setState(updatedState);
      }

      prevStateRef.current = state;
      return newFilters;
    });
  }, [data, id, setFilters, state, setState, defaultValue, urlOverride]);
};

export default useFilterUpdater;
