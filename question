import { useEffect, useRef } from "react";

const useFilterUpdater = (
  data,
  id,
  setFilters,
  state,
  setState,
  defaultValue = null,
  urlOverride = null
) => {
  // Track previous options to detect when they actually change
  const prevOptionsRef = useRef(null);
  const isInitialMount = useRef(true);
  const lastValidationOptions = useRef(null);

  useEffect(() => {
    // Skip initial mount to avoid unnecessary updates
    if (isInitialMount.current) {
      isInitialMount.current = false;
      if (data && data.options) {
        prevOptionsRef.current = data.options;
      }
      return;
    }

    // Don't process if data is not ready or is loading
    if (!data) return;

    const newOptions = data.options || [];
    const newOptionsLabels = data.optionsLabels || [];
    const newOptionsSx = data.optionsSx || [];

    // CRITICAL FIX: Detect if options went from populated to empty
    // This indicates a loading/fetching state, so we should preserve current state
    const isLikelyLoading =
      newOptions.length === 0 &&
      prevOptionsRef.current !== null &&
      prevOptionsRef.current.length > 0;

    if (isLikelyLoading) {
      // Don't update anything - wait for real data to arrive
      // console.log(
      //   `[${id}] Skipping update - likely loading state (empty options)`
      // );
      return;
    }

    // Check if options actually changed (not just re-rendered)
    const optionsChanged =
      JSON.stringify(prevOptionsRef.current) !== JSON.stringify(newOptions);

    // Update the reference only after we've decided to process this change
    prevOptionsRef.current = newOptions;

    let updatedState;

    // Calculate the updated state based on new options
    if (Array.isArray(state)) {
      // ===== MULTI SELECT =====

      // PRIORITY 1: Try to preserve URL override if it's valid
      if (urlOverride && Array.isArray(urlOverride)) {
        const validUrlValues = urlOverride.filter((d) =>
          newOptions.includes(d)
        );
        if (validUrlValues.length > 0) {
          updatedState = validUrlValues;
        } else {
          // URL values not in options yet, keep them temporarily
          updatedState = urlOverride;
        }
      } else {
        // PRIORITY 2: Try to preserve ALL current state values
        const allCurrentValuesStillValid =
          state.length > 0 && state.every((d) => newOptions.includes(d));

        if (allCurrentValuesStillValid) {
          // All values are still valid, keep the entire current state
          updatedState = state;
        } else if (optionsChanged && newOptions.length > 0) {
          // Options changed and we have new options
          const matchingStates = state.filter((d) => newOptions.includes(d));

          if (matchingStates.length > 0) {
            // Keep only the valid values
            updatedState = matchingStates;
          } else {
            // No matches, use default or first option
            updatedState = defaultValue
              ? [defaultValue]
              : newOptions.length > 0
              ? [newOptions[0]]
              : [];
          }
        } else {
          // Options didn't change or we have no new options, keep current state
          updatedState = state;
        }
      }
    } else {
      // ===== SINGLE SELECT =====

      // PRIORITY 1: Try to preserve URL override if it's valid
      if (urlOverride !== null) {
        const isUrlValid = newOptions.includes(urlOverride);
        if (isUrlValid) {
          updatedState = urlOverride;
        } else {
          // URL value not in options yet, keep it temporarily
          updatedState = urlOverride;
        }
      } else {
        // PRIORITY 2: Try to preserve current state
        const isStateValid = newOptions.includes(state);

        if (isStateValid) {
          // Current state is valid, keep it
          updatedState = state;
        } else if (optionsChanged && newOptions.length > 0) {
          // State invalid and options changed, use default or first option
          updatedState = defaultValue ?? newOptions[0] ?? "";
        } else {
          // State invalid but options didn't change or no new options, keep current state
          updatedState = state;
        }
      }
    }

    // Update filters with new options and calculated state
    setFilters((prevFilters) =>
      prevFilters.map((filter) => {
        if (filter.id === id) {
          return {
            ...filter,
            state: updatedState,
            options: newOptions,
            optionsLabels: newOptionsLabels,
            optionsSx: newOptionsSx,
          };
        }
        return filter;
      })
    );

    // Update local state if it changed (outside of setFilters callback)
    if (JSON.stringify(state) !== JSON.stringify(updatedState)) {
      // console.log(`[${id}] State update:`, {
      //   from: state,
      //   to: updatedState,
      //   reason: optionsChanged ? "options changed" : "validation",
      //   optionsLength: newOptions.length,
      // });
      setState(updatedState);
    }

    // --- VALIDATE FINAL STATE AFTER UPDATE ---
    // Only validate if:
    // 1. We have options
    // 2. Options have actually changed (not just re-render)
    // 3. These are different options than last validation (stabilized)
    const shouldValidate = 
      newOptions.length > 0 && 
      optionsChanged &&
      JSON.stringify(lastValidationOptions.current) !== JSON.stringify(newOptions);

    if (shouldValidate) {
      lastValidationOptions.current = newOptions;
      
      if (Array.isArray(updatedState)) {
        // Multi-select validation
        const validValues = updatedState.filter((val) => newOptions.includes(val));
        const invalidValues = updatedState.filter((val) => !newOptions.includes(val));
        
        if (invalidValues.length > 0) {
          console.warn(`[${id}] Invalid state values detected:`, invalidValues);
          // Keep valid values, or reset to default if none are valid
          const resetValue = validValues.length > 0 ? validValues : [defaultValue];
          setState(resetValue);
          setFilters((prevFilters) =>
            prevFilters.map((filter) => {
              if (filter.id === id) {
                return {
                  ...filter,
                  state: resetValue,
                };
              }
              return filter;
            })
          );
        }
      } else {
        // Single-select validation
        if (!newOptions.includes(updatedState)) {
          console.warn(`[${id}] Invalid state value detected:`, updatedState);
          // Reset to default value
          setState(defaultValue);
          setFilters((prevFilters) =>
            prevFilters.map((filter) => {
              if (filter.id === id) {
                return {
                  ...filter,
                  state: defaultValue,
                };
              }
              return filter;
            })
          );
        }
      }
    }
  }, [data, id, setFilters, state, setState, defaultValue, urlOverride]);
};

export default useFilterUpdater;